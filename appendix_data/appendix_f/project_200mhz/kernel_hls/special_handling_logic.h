#ifndef SPECIAL_HANDLING_LOGIC_H
#define SPECIAL_HANDLING_LOGIC_H
// 相较于v0_1版本，就是改了一下layernorm （_analyze_row_characteristics）
// THIS FILE IS AUTO-GENERATED BY hls_logic_generator.py
// DO NOT EDIT MANUALLY - ALL LOGIC IS DEFINED IN THE PYTHON SCRIPT

#include "accelerator.h" // For data_t, ActivationOpcode etc.
#include "accelerator_utils.h"

// ===================================================================================
//  NEW, MORE PRECISE DECISION CODES FOR dataflow2
// ===================================================================================
//  - PROCESS_NORMALLY:        Fallback to the regular computation pipeline (dataflow1).
//  - OUTPUT_ALL_NAN:          The result is mathematically undefined or involves NaNs.
//  - SOFTMAX_POS_INF_SPECIAL: Special case for Softmax with +Inf inputs.
//  - NORM_CONST_OVERFLOW:     For Norms, input is a large constant that would cause overflow.
//  - NORM_CONST_REGULAR:      For Norms, input is a well-behaved constant (zero variance).
// ===================================================================================
enum RowDecisionCode {
    PROCESS_NORMALLY,
    OUTPUT_ALL_NAN,
    SOFTMAX_POS_INF_SPECIAL,
    NORM_CONST_OVERFLOW,
    NORM_CONST_REGULAR
};

struct RowCharacteristics {
    RowDecisionCode code;
    int p_inf_count;
    data_t first_val;
};

// --- Auto-Generated Function Implementations ---

RowCharacteristics _analyze_row_characteristics(
    hls::stream<data_t>& in,
    ActivationOpcode opcode
) {
    #pragma HLS INLINE off
    data_t row_bram[D_DIM];
    // #pragma HLS BIND_STORAGE variable=row_bram type=RAM_1P impl=BRAM
    // =======================================================================
    // START OF THE FIX: Change RAM_1P to RAM_2P
    // =======================================================================
    // By changing the memory type from single-port (1P) to dual-port (2P),
    // we provide two access ports to the memory. This allows the pipelined
    // loop to perform one read (from row_bram[0]) and one write (to row_bram[i])
    // simultaneously in the same clock cycle, resolving the resource conflict.
    #pragma HLS BIND_STORAGE variable=row_bram type=RAM_2P impl=BRAM
    // =======================================================================
    // END OF THE FIX
    // =======================================================================
    int nan_count = 0, p_inf_count = 0, n_inf_count = 0;
    bool is_all_same = true;
    // NEW: Flag to detect potentially overflowing large finite numbers.
    // This flag is ONLY used by the LayerNorm logic.
    bool has_large_finite_val = false;

    for (int i = 0; i < D_DIM; ++i) {
        #pragma HLS PIPELINE II=1
        data_t val = in.read();
        row_bram[i] = val;
        if (bf16_is_nan(val)) { nan_count++; }
        else if (bf16_is_inf(val)) {
            if (val & 0x8000) n_inf_count++;
            else p_inf_count++;
        } else {
            // NEW: Check for large finite numbers specifically for LayerNorm's needs.
            // The largest exponent for a finite bf16 is 254 (0xFE).
            // A threshold of 250 is a safe way to detect values near the overflow boundary.
            ap_uint<8> exp_field = (val >> 7) & 0xFF;
            if (exp_field > 250) {
                has_large_finite_val = true;
            }
        }
        if (i > 0 && val != row_bram[0]) { is_all_same = false; }
    }

    RowCharacteristics result;
    result.p_inf_count = p_inf_count;
    result.first_val = row_bram[0];

    switch(opcode) {
        case OP_SOFTMAX: {
            // =======================================================================
            //  START OF MODIFICATION FOR SOFTMAX
            // =======================================================================
            // The regular pipeline (dataflow1) will be enhanced to handle most special
            // cases, including rows with only +Inf or only NaNs, mimicking the behavior
            // of the Python reference model (which uses nansum).
            // The only case that requires a definitive shortcut is when +Inf and -Inf
            // appear together, as max(+Inf, -Inf) is +Inf, and (+Inf - +Inf) is NaN,
            // while (-Inf - +Inf) is -Inf. The result is guaranteed to be NaN for all elements.
            if (p_inf_count > 0 && n_inf_count > 0) {
                result.code = OUTPUT_ALL_NAN;
            }
            // All other cases, including those with only +Inf or only NaN, are now
            // robustly handled by the regular pipeline.
            else {
                result.code = PROCESS_NORMALLY;
            }
            // =======================================================================
            //  END OF MODIFICATION FOR SOFTMAX
            // =======================================================================
            break;
        }

        case OP_LAYERNORM: {
            // =======================================================================
            //  START OF MODIFICATION FOR LAYERNORM
            // =======================================================================
            // MODIFIED: In addition to checking for Infs, we now also check if the
            // new flag `has_large_finite_val` was triggered. If so, we preemptively
            // classify the row to output NaN, matching the golden model's behavior
            // for inputs that cause internal overflow.
            if (p_inf_count > 0 || n_inf_count > 0 || has_large_finite_val) {
                result.code = OUTPUT_ALL_NAN;
            }
            else if (is_all_same) {
                data_t c = row_bram[0];
                ap_uint<8> exp_field = (c >> 7) & 0xFF;
                bool is_subnormal = (exp_field == 0 && !bf16_is_zero(c));

                if (is_subnormal) {
                    result.code = PROCESS_NORMALLY;
                } else {
                    if (exp_field > 190 && !bf16_is_zero(c)) {
                        result.code = NORM_CONST_OVERFLOW;
                    } else {
                        result.code = NORM_CONST_REGULAR;
                    }
                }
            }
            else {
                result.code = PROCESS_NORMALLY;
            }
            // =======================================================================
            //  END OF MODIFICATION FOR LAYERNORM
            // =======================================================================
            break;
        }
        case OP_RMSNORM: {
            // =======================================================================
            //  START OF RMSNORM-SPECIFIC FIX: Relax the Inf check
            // =======================================================================
            // Unlike LayerNorm, RMSNorm doesn't compute a mean, so the presence
            // of a single Inf doesn't automatically mean the output is all NaNs.
            // The main pipeline is now capable of handling this correctly
            // (e.g., finite/inf -> 0). We let ऑल cases, including those with Inf,
            // pass through to the regular pipeline for correct calculation.
            // The only special cases we handle here are constant rows, which
            // dataflow2 is well-suited for.
            if (is_all_same) {
                data_t c = row_bram[0];
                ap_uint<8> exp_field = (c >> 7) & 0xFF;
                bool is_subnormal = (exp_field == 0 && !bf16_is_zero(c));

                if (is_subnormal) {
                    result.code = PROCESS_NORMALLY;
                } else {
                     if (exp_field > 190 && !bf16_is_zero(c)) {
                        result.code = NORM_CONST_OVERFLOW;
                    } else {
                        result.code = NORM_CONST_REGULAR;
                    }
                }
            }
            else {
                // Let dataflow1 handle all non-constant rows, including those with Inf.
                result.code = PROCESS_NORMALLY;
            }
            // =======================================================================
            //  END OF RMSNORM-SPECIFIC FIX
            // =======================================================================
            break;
        }
        default: {
            result.code = PROCESS_NORMALLY;
            break;
        }
    }
    return result;
}

void _softmax_finalize_row(RowCharacteristics d, hls::stream<data_t>& reg_in, hls::stream<data_t>& out) {
    #pragma HLS INLINE off
    switch (d.code) {
        case OUTPUT_ALL_NAN:
            for (int i=0; i<D_DIM; ++i) {
                #pragma HLS PIPELINE II=1
                reg_in.read();
                // orig_in.read(); <-- DELETED
                out.write(BF16_NAN);
            }
            break;

        case PROCESS_NORMALLY:
            for (int i=0; i<D_DIM; ++i) {
                #pragma HLS PIPELINE II=1
                // orig_in.read(); <-- DELETED
                out.write(reg_in.read());
            }
            break;

        default: // Should be unreachable, but write NaN for safety
            for (int i=0; i<D_DIM; ++i) {
                #pragma HLS PIPELINE II=1
                reg_in.read();
                // orig_in.read(); <-- DELETED
                out.write(BF16_NAN);
            }
            break;
    }
}

void _layernorm_finalize_row(RowCharacteristics d, hls::stream<data_t>& reg_in, hls::stream<data_t>& out) {
    #pragma HLS INLINE off
    switch (d.code) {
        // =======================================================================
        //  START OF FINAL FIX 1: Correcting the Overflow Shortcut
        // =======================================================================
        // When input is a large constant, sum_sq overflows, leading to var = Inf-Inf = NaN.
        // The correct special case output is NaN, not zero.
        case NORM_CONST_OVERFLOW:
        case OUTPUT_ALL_NAN:
            for (int i=0; i<D_DIM; ++i) {
                #pragma HLS PIPELINE II=1
                reg_in.read(); out.write(BF16_NAN);
            }
            break;
        // =======================================================================
        //  END OF FINAL FIX
        // =======================================================================

        case NORM_CONST_REGULAR: // Zero variance case for well-behaved numbers
            for (int i=0; i<D_DIM; ++i) {
                #pragma HLS PIPELINE II=1
                reg_in.read();
                out.write(BF16_ZERO);
            }
            break;

        case PROCESS_NORMALLY:
            for (int i=0; i<D_DIM; ++i) {
                #pragma HLS PIPELINE II=1
                out.write(reg_in.read());
            }
            break;

        default: // Should be unreachable, but write NaN for safety
            for (int i=0; i<D_DIM; ++i) {
                #pragma HLS PIPELINE II=1
                reg_in.read(); out.write(BF16_NAN);
            }
            break;
    }
}

void _rmsnorm_finalize_row(RowCharacteristics d, hls::stream<data_t>& reg_in, hls::stream<data_t>& out) {
    #pragma HLS INLINE off
    switch (d.code) {
        // =======================================================================
        //  START OF FINAL RMSNORM FIX 1: Correct the Overflow Shortcut
        // =======================================================================
        // When the input is a large constant, mean_sq overflows to Inf. The correct
        // mathematical result is x / Inf = 0, not NaN. We now enforce this.
        case NORM_CONST_OVERFLOW:
            for (int i=0; i<D_DIM; ++i) {
                #pragma HLS PIPELINE II=1
                reg_in.read(); // Must consume the invalid data from the regular pipeline
                out.write(BF16_ZERO);
            }
            break;
        // =======================================================================
        //  END OF FINAL RMSNORM FIX 1
        // =======================================================================

        // This case might be triggered by other logic paths, so we keep it for safety.
        case OUTPUT_ALL_NAN:
            for (int i=0; i<D_DIM; ++i) {
                #pragma HLS PIPELINE II=1
                reg_in.read();
                out.write(BF16_NAN);
            }
            break;

        // =======================================================================
        //  START OF FINAL RMSNORM FIX 2: Decommission the Regular Constant Shortcut
        // =======================================================================
        // The previous shortcut for regular constants (outputting +/-1) was too
        // simplistic because it did not account for the 'epsilon' term. This
        // caused errors for very small inputs (e.g., MIN_NORMAL), where x*x
        // underflows to zero and epsilon becomes dominant. The main pipeline
        // (dataflow1) handles this correctly. Therefore, we now treat this case
        // identically to PROCESS_NORMALLY, trusting dataflow1's result.
        case NORM_CONST_REGULAR:
        case PROCESS_NORMALLY:
            for (int i=0; i<D_DIM; ++i) {
                #pragma HLS PIPELINE II=1
                out.write(reg_in.read());
            }
            break;
        // =======================================================================
        //  END OF FINAL RMSNORM FIX 2
        // =======================================================================

        default: // Should be unreachable, but write NaN for safety
            for (int i=0; i<D_DIM; ++i) {
                #pragma HLS PIPELINE II=1
                reg_in.read(); out.write(BF16_NAN);
            }
            break;
    }
}

#endif // SPECIAL_HANDLING_LOGIC_H
